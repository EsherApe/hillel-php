-- phpMyAdmin SQL Dump
-- version 4.0.10.10
-- http://www.phpmyadmin.net
--
-- Хост: 127.0.0.1:3306
-- Время создания: Фев 01 2017 г., 19:06
-- Версия сервера: 5.5.45
-- Версия PHP: 5.6.12

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- База данных: `mvc_project`
--

-- --------------------------------------------------------

--
-- Структура таблицы `articles`
--

CREATE TABLE IF NOT EXISTS `articles` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(250) NOT NULL,
  `text` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

--
-- Дамп данных таблицы `articles`
--

INSERT INTO `articles` (`id`, `title`, `text`) VALUES
(1, 'Как работать с PDO? Полное руководство.', 'Вступление\r\nС тех пор, как тронувшиеся умом разработчики РНР решили запретить невинную библиотеку mysql, для тех пользователей, кто привык напрямую работать с функциями mysql API в коде приложения, остался только один выбор - PDO.\r\n\r\nПо-хорошему, надо бы, конечно, завернуть все обращения к API в библиотеку, и пользоваться только ей. Но поскольку среднего РНР юзера очень сложно убедить отказаться от обращений к API напрямую, то лучше уж научить его, как это делать правильно.\r\n\r\nДля начала - почему PDO. Причины очень простые. Для работы с Mysql выбирать можно из трёх API:\r\n\r\n- старое доброе расширение mysql. В 5-й версии нудит нотисами о том, что устарело, а из 7-й уже удалено совсем. Плюс форменная истерика в интернетах на её счёт (абсолютно беспочвенная при этом. Бандерлоги так и не научились правильно ей пользоваться, но все свои проблемы решили свалить на неё).\r\n- mysqli. Эта библиотека не предназначена для испрользования напрямую в коде. А только как строительный материал для создания библиотеки более высокого уровня. Напрямую же ей пользоваться невозможно. Легче пережить небольшую атомную войну, чем попытаться привязать несколько переменных в оператор IN(). \r\n- PDO - тупо методом исключения: ничего другого все равно больше не остаётся. Тем более, что это такой недо-DAL, который делает много того, что должна делать библиотека для работы с SQL (но ещё больше она не делает, о чем речь пойдёт ниже)\r\n\r\nСоединение\r\n\r\nУ PDO свой собственный хитровыдуманный способ соединения, называемый DSN. Плюс во время коннекта можно задать хренову тучу опций, некоторые из которых чрезвычайно полезны. Полный список можно найти здесь, но важными из них являются только несколько.\r\n\r\nПример правильного соединения:\r\n\r\n$dsn = "mysql:host=$host;dbname=$db;charset=$charset";\r\n$opt = array(\r\n    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,\r\n    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC\r\n);\r\n$pdo = new PDO($dsn, $user, $pass, $opt);\r\n\r\nЧто здесь происходит?\r\n\r\n- в $dsn задается тип БД, с которым будем работать (mysql), хост, имя базы данных и чарсет.\r\n- затем идут имя пользователя и пароль\r\n- после которого задается массив опций, про который ни в одном из руководств не пишут.\r\n\r\nПри том что этот массив - чрезвычайно полезная, как уже говорилось выше, штука. Самое главное - режим выдачи ошибок надо задавать только в виде исключений. \r\n- Во-первых, потому что во всех остальных режимах PDO не сообщает об ошибке ничего внятного,\r\n- во-вторых, потому что исключение всегда содержит в себе незаменимый stack trace, \r\n- в-третьих - исключения чрезвычайно удобно обрабатывать. \r\n\r\nПлюс очень удобно задать FETCH_MODE по умолчанию, чтобы не писать его в КАЖДОМ запросе, как это очень любят делать прилежные хомячки. \r\nТакже здесь можно задавать режим pconnect-а, эмуляции подготовленных выражений и много других страшных слов.\r\n\r\nВ результате мы получаем переменную $pdo, с которой и работаем далее на протяжении всего скрипта.\r\n\r\nОбработка исключений\r\nПоскольку практически КАЖДЫЙ мануал по PDO считает своим долгом продемонстрировать в корне неверный способ обработки исключений, я должен сделать специальное пояснение. \r\nОбычно пример выглядит как-то так\r\ntry {\r\n    $dbh = new PDO($dsn, $user, $password);\r\n} catch (PDOException $e) {\r\n    die(''Подключение не удалось: '' . $e->getMessage());\r\n}\r\nТак вот, дети, запомните: так делать не надо НИКОГДА. \r\nДля того, чтобы всего лишь показать ошибку, try..catch используют только дураки:\r\n- во-первых, этот код избыточен: РНР покажет ошибку и так, безо всяких try..catch.\r\n- во-вторых, этот код гораздо менее гибкий: он выводит ошибку ТОЛЬКО на экран, в то время как исключение улетит туда же, куда и все остальные ошибки: либо в лог файл, либо на экран, в зависимости от глобальных настроек.\r\n- в-третьих, этот код лишает нас возможности обрабатывать все ошибки централизованно, в едином exception handler-е. \r\n\r\nПоэтому использовать try..catch нужно только тогда, когда вы собираетесь ОБРАБОТАТЬ ошибку - то есть, совершить какое-то действие, связанное с ФАКТОМ ошибки - откатить транзакцию, например. Для того же, чтобы просто выдать сообщение об ошибке, try..catch использовать не нужно - PHP прекрасно справится сам\r\n\r\nВыполнение запросов.\r\n\r\nДля выполнения запросов можно пользоваться двумя методами. \r\nЕсли в запрос не передаются никакие переменные, то можно воспользоваться функцией query(). Она выполнит запрос и вернёт специальный объект — PDO statement. Очень грубо можно его сравнить с mysql resource, который возвращала mysql_query(). Получить данные из этого объекта можно как традиционным образом, через while, так и через foreach(). Также можно попросить вернуть полученные данные в особом формате, о чем ниже.\r\n$stmt = $pdo->query(''SELECT name FROM users'');\r\nwhile ($row = $stmt->fetch())\r\n{\r\n    echo $row[''name''] . "\\n";\r\n}\r\n\r\nПодготовленные выражения\r\n\r\nЕсли же в запрос передаётся хотя бы одна переменная, то этот запрос в обязательном порядке должен выполняться только через подготовленные выражения. Что это такое? Это обычный SQL запрос, в котором вместо переменной ставится специальный маркер - плейсхолдер. PDO поддерживает позиционные плейсхолдеры (?), для которых важен порядок передаваемых переменных, и именованные (:name), для которых порядок не важен. Примеры:\r\n$sql = ''SELECT name FROM users WHERE email = ?'';\r\n$sql = ''SELECT name FROM users WHERE email = :email'';\r\nЧтобы выполнить такой запрос, сначала его надо подготовить с помощью функции prepare(). Она также возвращает PDO statement, но ещё без данных. Чтобы их получить, надо исполнить этот запрос, предварительно передав в него переменные. Передать можно двумя способами:\r\nЧаще всего можно просто выполнить метод execute(), передав ему массив с переменными:\r\n$stmt = prepare(''SELECT name FROM users WHERE email = ?'')\r\n$stmt->execute(array($email));\r\n\r\n$stmt = prepare(''SELECT name FROM users WHERE email = :email'');\r\n$stmt->execute(array(''email'' => $email));\r\nКак видно, в случае именованных плейсхолдеров в execute() должен передаваться массив, в котором ключи должны совпадать с именами плейсхолдеров.\r\n\r\nИногда, очень редко, может потребоваться второй способ, когда переменные сначала привязывают к запросу по одной, с помощью bindValue() / bindParam(), а потом только исполняют. В этом случае в execute() ничего не передается. Пример можно посмотреть в мануале\r\nИспользуя этот метод, всегда следует предпочесть bindValue()? поскольку поведение bindParam() не очевидно для новичков и будет приводить к проблемам.\r\n\r\nПосле этого можно использовать PDO statement теми же способами, что и выше. Например, через foreach:\r\n$stmt = $pdo->prepare(''SELECT name FROM users WHERE email = ?'');\r\n$stmt->execute([$_GET[''email'']]);\r\nforeach ($stmt as $row)\r\n{\r\n    echo $row[''name''] . "\\n";\r\n}\r\n\r\nВАЖНО: Подготовленные выражения - основная причина использовать PDO, поскольку это единственный безопасный способ выполнения SQL запросов, в которых участвуют переменные. \r\n\r\nПодготовленные выражения. Множественное выполнение.\r\n\r\nТакже prepare() / execute() могут использоваться для многократного выполнения единожды подготовленного запроса с разными наборами данных. На практике это бывает нужно чрезвычайно редко, и особого прироста в скорости не приносит. Но на случай, если онадобится выполнять делать много однотипных запросов, то можно писать так:\r\n\r\n$data = array(\r\n1 => 1000,\r\n5 => 300,\r\n9 => 200,\r\n);\r\n\r\n$stmt = $pdo->prepare(''UPDATE users SET bonus = bonus + ? WHERE id = ?'');\r\nforeach ($data as $id => $bonus)\r\n{\r\n    $stmt->execute([$bonus,$id]);\r\n}\r\n\r\nЗдесь мы один раз подготавливаем запрос, а затем много раз выполняем.\r\n\r\nПолучение данных. fetch()\r\n\r\nМы уже выше познакомились с методом fetch(), который служит для последовательного получения строк из БД. Этот метод является аналогом функции mysq_fetch_array() и ей подобных, но действует по-другому: вместо множества функций здесь используется одна, но ее поведение задается переданным параметром. В подробностях об этих параметрах будет написано позже, а в качестве краткой рекомендации посоветую применять fetch() в режиме FETCH_LAZY:\r\n$stmt = $pdo->prepare(''SELECT name FROM users WHERE email = ?'');\r\n$stmt->execute([$_GET[''email'']]);\r\nwhile ($row = $stmt->fetch(PDO::FETCH_LAZY))\r\n{\r\n    echo $row[0] . "\\n";\r\n    echo $row[''name''] . "\\n";\r\n    echo $row->name . "\\n";\r\n}\r\nВ этом режиме не тратится лишняя память, и к тому же к колонкам можно обращаться любым из трех способов - через индекс, имя, или свойство.\r\n\r\nПолучение данных. fetchColumn()\r\n\r\nТакже у PDO statement есть функция-хелпер для получения значения единственной колонки. Очень удобно, если мы запрашиваем только одно поле - в этом случае значительно сокращается количество писанины:\r\n$stmt = $pdo->prepare("SELECT name FROM table WHERE id=?");\r\n$stmt->execute(array($id));\r\n$name = $stmt->fetchColumn();\r\n\r\nПолучение данных. fetchAll()\r\n\r\nНо самой интересной функцией, с самым большим функционалом, является fetchAll(). Именно она делает PDO высокоуровневой библиотекой для работы с БД, а не просто низкоуровневым драйвером. \r\n\r\nfetchAll() возвращает массив, который состоит из всех строк, которые вернул запрос. Из чего можно сделать два вывода:\r\n1. Эту функцию не стоит применять тогда, когда запрос возвращает много данных. В таком случае лучше использовать традиционный цикл с fetch()\r\n2. Поскольку в современных РНР приложениях данные никогда не выводятся сразу по получении, а передаются для этого в шаблон, fetchAll() становится просто незаменимой, позволяя не писать циклы вручную, и тем самым сократить количество кода.\r\n\r\nПолучение простого массива. \r\nВызванная без параметров, эта функция возвращает обычный индексированный массив, в котором лежат строки из бд, в формате, который задан в FETCH_MODE по умолчанию. Константы PDO::FETCH_NUM, PDO::FETCH_ASSOC, PDO::FETCH_OBJ могут менять формат на лету.\r\n\r\nПолучение колонки.\r\nИногда бывает нужно получить простой одномерный массив, запросив единственное поле из кучи строк. Для этого используется режим PDO::FETCH_COLUMN\r\n$data = $pdo->query(''SELECT name FROM users'')->fetchAll(PDO::FETCH_COLUMN);\r\narray (\r\n  0 => ''John'',\r\n  1 => ''Mike'',\r\n  2 => ''Mary'',\r\n  3 => ''Kathy'',\r\n)\r\n\r\nПолучение пар ключ-значение.\r\nТакже востребованный формат, когда желательно получить ту же колонку, но индексированную не числами, а одним из полей. За это отвечает константа PDO::FETCH_KEY_PAIR. \r\n$data = $pdo->query(''SELECT id, name FROM users'')->fetchAll(PDO::FETCH_KEY_PAIR);\r\narray (\r\n  104 => ''John'',\r\n  110 => ''Mike'',\r\n  120 => ''Mary'',\r\n  121 => ''Kathy'',\r\n)\r\nСледует помнить, что первой в колонкой надо обязательно выбирать уникальное поле.\r\n\r\nПолучение всех строк, индексированных полем.\r\nТакже часто бывает нужно получить все строки из БД, но также индексированные не числами, а уникальным полем. Это делает константа PDO::FETCH_UNIQUE\r\n$data = $pdo->query(''SELECT * FROM users'')->fetchAll(PDO::FETCH_UNIQUE);\r\narray (\r\n  104 => array (\r\n    ''name'' => ''John'',\r\n    ''car'' => ''Toyota'',\r\n  ),\r\n  110 => array (\r\n    ''name'' => ''Mike'',\r\n    ''car'' => ''Ford'',\r\n  ),\r\n  120 => array (\r\n    ''name'' => ''Mary'',\r\n    ''car'' => ''Mazda'',\r\n  ),\r\n  121 => array (\r\n    ''name'' => ''Kathy'',\r\n    ''car'' => ''Mazda'',\r\n  ),\r\n)\r\nСледует помнить, что первой в колонкой надо обязательно выбирать уникальное поле.\r\n\r\nВсего различных режимов получения данных в PDO больше полутора десятков. Плюс ещё их можно комбинировать! Но это уже тема для отдельной статьи.\r\n\r\nPDO и оператор LIKE\r\n\r\nРаботая с подготовленными выражениями, следует понимать, что плейсхолдер может заменять только строку или число. Ни ключевое слово, ни идентификатор, ни часть строки или набор строк через плейсхолдер подставить нельзя. Поэтому для LIKE надо сначала подготовить строку поиска целиком, а потом ее подставлять в запрос:\r\n\r\n$name = "%$name%";\r\n$stm  = $pdo->prepare("SELECT * FROM table WHERE name LIKE ?");\r\n$stm->execute(array($name));\r\n$data = $stm->fetchAll();\r\n\r\nPDO и оператор LIMIT\r\nЗдесь есть один нюанс.\r\nКогда PDO работает в режиме эмуляции, все данные, которые были переданы напрямую в execute(), форматируются как строки. То есть, эскейпятся и обрамляются кавычками. Поэтому LIMIT ?,? превращается в LIMIT ''10'', ''10'' и очевидным образом вызывает ошибку синтаксиса.\r\n\r\nСоответственно, есть 2 решения:\r\n- либо отключить режим эмуляции\r\n$conn->setAttribute( PDO::ATTR_EMULATE_PREPARES, false );\r\nЛибо биндить эти цифры через bindValue, принудительно выставляя им тип PDO::PARAM_INT.\r\n$stm = $pdo->prepare(''SELECT * FROM table LIMIT ?, ?'');\r\n$stm->bindValue(1, $limit_from, PDO::PARAM_INT);\r\n$stm->bindValue(2, $per_page, PDO::PARAM_INT);\r\n$stm->execute();\r\n$data = $stm->fetchAll();\r\n\r\nPDO и оператор IN\r\nКак уже говорилось выше, плейсхолдер может представлять только строку или число. Подставить набор данных на место одного плейсхолдера не получится. \r\nПоэтому для IN придется изворачиваться, динамически формируя две переменные:\r\n- набор вопросиков через запятую по числу элементов в IN()\r\n- и массив данных для подстановки.\r\nВ отличие от mysqli кода получается не очень много, но все равно - сразу не сообразишь:\r\n\r\n$arr = array(1,2,3);\r\n$in  = str_repeat(''?,'', count($arr) - 1) . ''?'';\r\n$sql = "SELECT * FROM table WHERE column IN ($in)";\r\n$stm = $db->prepare($sql);\r\n$stm->execute($arr);\r\n$data = $stm->fetchAll();\r\n\r\nPDO и имена полей/таблиц\r\n\r\nНу, вы поняли. Тут тоже всё плохо. PDO не предоставляет вообще никаких средств для работы с идентификаторами, и их надо форматировать по-старинке, вручную (или посмотреть, все-таки, в сторону SafeMysql, в которой этот, как и многие другие вопросы, решены просто и элегантно). Для ручного форматирования идентификатора необходимо выполнить два правила:\r\n- заключить его в обратные одинарные кавычки (backticks, "`").\r\n- проискейпить их путём удвоения.\r\n\r\n$field = "`".str_replace("`","``",$_GET[''field''])."`";\r\n$sql   = "SELECT * FROM `table` ORDER BY $field";\r\n\r\nОднако, здесь есть один нюанс. Одного форматирования может быть недостаточно. приведенный выше код гарантирует нас от классической инъекции, но в некоторых случаях враг все равно может записать что-то нежелательное, если мы бездумно подставляем имена полей и таблиц прямиком в запрос. К примеру, есть в таблице users поле admin. Если входящие имена полей не фильтровать, то в это поле, при автоматическом формировании запроса из POST-а, любой дурак запишет любую гадость.\r\n\r\nПоэтому имена таблиц и полей, приходящие от юзера, желательно проверять на допустимость, как в приведённом ниже примере\r\n\r\nPDO и запросы INSERT/UPDATE\r\n\r\nЛюбой код для вставки, который можно увидеть в многочисленных туториалах, навевает тоску и желание убиться апстену. Многокилометровые построения с повторением одних и тех же имен - в идексах $_POST-а, в именах переменных, в именах полей в запросе, в именах плейсхолдеров в запросе, в именах плейсходеров и именах переменных при привязке. \r\nГлядя на этот код, хочется кого-нибудь убить, или, по крайней мере, сделать его немного короче. \r\n\r\nЭто можно сделать, если принять соглашение, по которому имена полей в форме будут соответствовать именам полей в таблице. Тогда эти имена можно будет перечислить только один раз (в целях защиты от подмены, о которой говорилось выше), и использовать небольшую функцию-хелпер для сборки запроса, которая, в силу особенностей mysql, годится как для INSERT, так и UPDATE запросов:\r\n\r\nfunction pdoSet($allowed, &$values, $source = array()) {\r\n  $set = '''';\r\n  $values = array();\r\n  if (!$source) $source = &$_POST;\r\n  foreach ($allowed as $field) {\r\n    if (isset($source[$field])) {\r\n      $set.="`".str_replace("`","``",$field)."`". "=:$field, ";\r\n      $values[$field] = $source[$field];\r\n    }\r\n  }\r\n  return substr($set, 0, -2); \r\n}\r\n\r\nСоответственно, для вставки код будет\r\n\r\n$allowed = array("name","surname","email"); // allowed fields\r\n$sql = "INSERT INTO users SET ".pdoSet($allowed,$values);\r\n$stm = $dbh->prepare($sql);\r\n$stm->execute($values);\r\n\r\nА для апдейта - такой:\r\n\r\n$allowed = array("name","surname","email","password"); // allowed fields\r\n$_POST[''password''] = MD5($_POST[''login''].$_POST[''password'']);\r\n$sql = "UPDATE users SET ".pdoSet($allowed,$values)." WHERE id = :id";\r\n$stm = $dbh->prepare($sql);\r\n$values["id"] = $_POST[''id''];\r\n$stm->execute($values);\r\n\r\nНе слишком эффектно, но зато очень эффективно. Напомню, кстати, что если использовать Класс для безопасной и удобной работы с MySQL, то это всё делается в две строчки. \r\n\r\nPDO и ключевые слова\r\nЗдесь кроме фильтрации ничего придумать невозможно. поэтому тупо прогонять все не прописанные в запросе напрямую операторы через белый список:\r\n\r\n$dirs = array("ASC","DESC");\r\n$key  = array_search($_GET[''dir''],$dirs));\r\n$dir  = $orders[$key];\r\n$sql  = "SELECT * FROM `table` ORDER BY $field $dir";');
INSERT INTO `articles` (`id`, `title`, `text`) VALUES
(2, 'M в MVC: почему модели непоняты и недооценены', '(статья очень старая, по поднятые в ней вопросы актуальны по сей день и регулярно поднимаются в различных обсуждениях)\r\n\r\nМногие из вас наверняка заметили, что я пишу книгу о Zend Framework. Недавно я закончил черновики двух глав: «Архитектура приложений на Zend Framework» и «Понимая Zend Framework». В первой главе объясняется архитектурный шаблон Model-View-Controller (MVC) и причины, по которым он стал стандартом де-факто для веб-приложений. Во второй исследуется связь MVC с компонентами Zend Framework, их структурой и взаимодействием. \r\n\r\nЗавершив обе главы я осознал, что большую часть времени описывал модель и ее фактическое отсутствие в Zend Framework. На самом деле ни один веб-фреймворк не предлагает нам полноценную модель (по причинам, которые я объясню чуть позже). И ни в одном из них не дается внятного объяснения этому обстоятельству. Вместо этого они последовательно связывают понятие модели с родственным, но не идентичным понятием доступа к данным, что изрядно всех запутывает.\r\n\r\nЭта сторона фреймворков никогда не привлекала особого внимания. И все же именно она лежит в основе целого класса проблем в тех приложениях, которые пытаются использовать MVC по образу и подобию фреймворков для веб-приложений. Более того, попытки донести идею модели до других разработчиков нередко напоминают битье головой о стену. Я не хочу сказать, что все разработчики тупые или не понимают саму идею, просто никто из них (вне зависимости от того, работают они с PHP или нет) не связывает модели с той областью, которая наделяет их смыслом — принципами объектно-ориентированного программирования.\r\n\r\nВ этой записи я исследую модели в свете того, как разработчики соотносят их с контролерами и представлениями в приложениях и опишу несколько стратегий, которые можно использовать вместе с правильными моделями.\r\n\r\nМодели непоняты\r\n\r\nМодели можно описать по-разному. На самом деле только об этом можно написать целую книгу, многие именно так и поступали! Как правило описываются две роли модели:\r\n\r\n1. Модель отвечает за сохранения состояния между HTTP-запросами\r\n\r\nПо сути дела любые данные — в базе данных, файле, сохраненные в сессии или закешированные внутри APC, должны быть сохранены между запросами в виде состояния приложения на момент последнего запроса. Помните, модель не ограничивается базой данных. Даже получаемые из веб-сервисов данные могут быть представлены в виде модели! Да, даже ленты новостей в формате Atom! Стремящиеся побыстрее познакомить с моделью фреймворки этого никогда не объясняют, усиливая непонимание.\r\n\r\nВозьмем в качестве примера разрабатываемый мной компонент под названием Zend_Feed_Reader, который на самом деле является моделью. Он читает ленты новостей, обрабатывает их, интерпретирует данные, добавляет ограничения, правила и по большому счету создает удобное представление нижележащих данных. Без него мы имеем Zend_Feed (лучшее средство для чтения новостных лент на данный момент), который требует большого количества работы для получения полноценной модели. Другими словами, Zend_Feed_Reader является моделью, в то время как Zend_Feed ограничивается доступом к данным.\r\n\r\n2. Модель включает в себя все правила и ограничения, управляет поведением и использованием данной информации. \r\n\r\nДля примера, вы пишете бизнес-логику для модели заказа в снабженческом приложении и по внутренним правилам компании на покупки за наличные может быть наложено ограничение в 500 евро. Покупки на сумму более 500 евро должны быть запрещены в вашей модели заказа (для них может требоваться одобрение вышестоящего начальства). У модели должны быть средства для установки подобных ограничений.\r\n\r\nВсе станет предельно ясно, как только вы задумаетесь над смыслом слова «модель». В климатологии есть модели климата, описывающие данные, процессы, предполагаемое поведение и позволяющие рассчитать возможные результаты. М в MVC называется моделью не просто так. Модель представляет не только данные, она представляет всю систему, в которой полезны эти данные. Само собой система может быть настолько сложной, что ей понадобится несколько взаимодействующих моделей, но вы поняли идею.\r\n\r\nПрочитав эти два пункта вы скорее всего начали осознавать нечто поразительное. За исключением интерфейса, любое приложение можно представить в виде моделей. Именно в них сосредоточены данные, основанные на них правила поведения и, в некоторых случаях, даже вывод этих данных. Именно модель способна понять, истолковать и изложить данные, обеспечив им осмысленное использование. \r\n\r\nВ программировании толстые модели предпочтительнее моделей с нулевым размером \r\n\r\nДжамис Бак (Jamis Buck, автор Capistrano, сейчас работающий в 37signals) в свое время описал концепцию «Тощего контроллера, толстой модели». Крис Хартжес (Chris Hartjes) тоже написал статью на эту тему. Мне всегда нравилась простота этой концепции, так как она иллюстрирует ключевую особенность MVC. В рамках этой концепции считается, что по мере возможности логику приложения (вроде бизнес-логики из примера выше) лучше всего помещать в модель, а не контроллер или представление. \r\n\r\nПредставление должно заниматься только созданием и отображением интерфейса, через который пользователи смогут сообщить модели о своих намерениях. Контроллеры — это организаторы, связывающие введенные в интерфейс данные с действиями модели и передающие вывод обратно, какое бы представление ни отображало эту модель. Контроллеры должны определять поведение приложения только в плане связи ввода пользователя с вызовами модели, но в остальном должно быть ясно, что вся логика приложения находится в модели. Контроллеры — это скромные существа с минимумом кода, которые обеспечивают условия для упорядоченной работы. \r\n\r\nПо большому счету, php-разработчики не совсем понимают, что такое модель. Многие считают модель красивым словом для обозначения доступа к базе данных, другие приравнивают ее к разным шаблонам для доступа к базе данных, вроде Active Record, Data Mapper и Table Data Gateway. Фреймворки очень часто продвигают это заблуждение, ненамеренно, я уверен, но энергично. Не полностью понимая, что такое модель, почему это столь великолепная идея, и как ее надо разрабатывать и развертывать, разработчики непреднамеренно вступают на темный путь, ведущий к таким методикам разработки, которые иначе чем убогими и не назовешь.\r\n\r\nНебольшое мысленное упражнение даст вам почву для размышлений. Представьте, что вы только что написали самое замечательное в мире веб-приложение с использованием Zend Framework. Клиент поражен, его восторги (и деньги) крайне приятны. К несчастью они забыли упомянуть, что их новый технический директор требует использовать Symfony во всех новых приложениях и предлагает крайне интересную сумму за преобразование вашего приложения. Вопрос: насколько это будет просто? Задумайтесь об этом на секунду…\r\n\r\nЕсли логика вашего приложения завязана на модель — вы на коне! Symfony, подобно многим (но не всем) фреймворкам, принимает модели вне зависимости от того, поверх чего они написаны. Вы можете перенести вашу модель, ее юнит-тесты и вспомогательные классы на Symfony ничего или почти ничего не меняя. Если вы связали все это с контроллерами, у вас проблемы. Вы действительно считаете, что Symfony сможет использовать контроллеры Zend Framework? Что каким-то волшебным образом заработают функциональные тесты, использующие PHPUnit-расширение Zend Framework? Оба-на. Вот почему контроллеры не способны заменить модели. Их практически невозможно использовать повторно.\r\n\r\nНепонятые, недооцененные, нелюбимые: модели в депрессии\r\n\r\nТак как разработчики очень часто занижают роль модели, ограничивая ее доступом к базе данных, как это по умолчанию делается в 99,9% фреймворков, нет ничего удивительного, что их не впечатляют связанные с ней теоретические идеалы. Сосредотачиваясь на доступе к данным разработчики полностью пускают один очень важный момент: классы моделей не связаны с текущим фреймворком. Им не требуется сложная установка, вы просто создаете и используете их объекты.\r\n\r\nВозможно нам не стоит винить во всем среднего разработчика. У веб-приложений есть определенные поведенческие схемы, делающие эту кривую дорогу более привлекательной — большинство их них всего лишь очень большие считыватели данных. Если данные почти не обрабатываются, только читаются, то модель будет очень похожа на старый добрый доступ к данным. Не самое удачное стечение обстоятельств, так что не позволяйте простоте чтения данных одурачить вас. Не все приложения ограничиваются чтением — некоторые, вне всяких сомнений, должны делать с данными что-то выходящее за пределы отображения их в неизменном, соответствующем базе виде. \r\n\r\nМодели в PHP — неудачники. С момента появления Smarty и его сородичей все увлечены представлениями. Контроллеры тоже очень важны, так как они считывают данные из базы и передают в шаблоны (общепринятая интерпретация VC). Да-да, контроллеры — это логичная эволюция въевшегося в мозг контроллера страницы, который используется каждым PHP-разработчиком и его собакой начиная с PHP3. Как минимум большинству это кажется очевидным. Мы разрушим миф о «контроллере = контроллеру страницы» позже. \r\n\r\nА модели? Так как у них нет идеологической привлекательности или схожести со старыми привычками, люди рассматривают их как банальный «доступ к данным». Подобно ссылочным типам в PHP, указывающим на одно и то же значение в памяти. Язык изменился, но старые идеи все еще прячутся за кулисами, сбивая с толку наши нейронные сети. \r\n\r\nНо постойте… ведь разработчики все-таки пишут работающие приложения! И если они не используют модели, содержащие логику приложения, то что же, черт побери, они используют?!\r\n\r\nТолстые, тупые, уродливые контроллеры: смиритесь (Fat Stupid Ugly Controllers: SUC It Up)\r\n\r\nТак как разработчики почти ничего не знали о моделях, они изобрели новое понятие: толстые тупые уродливые контроллеры (ТТУК). Столь яркое определение я придумал не просто так, оно кажется очень забавным в 10 вечера, после нескольких кружек пива. И все равно вежливее того, что я о них на самом деле думаю. (Fat Stupid Ugly Controllers — FSUC — FUC). Их изобрели потому, что модели были непривычными, чуждыми и похожими на террористов сущностями, которым никто не решался доверить хоть что-то выходящее за пределы доступа к данным. \r\n\r\nТипичный ТТУК читает данные с базы (используя уровень абстракции данных, который разработчики называют моделью), обрабатывает их, проверяет, пишет и передает в представление для вывода на экран. Он невероятно популярен. Я бы сказал, что большинство пользователей фреймворков создают их так же естественно, как раньше создавали контроллеры страницы (Page Controllers). Они популярны, потому что разработчики осознали, что они могут обращаться с контроллерами почти так же, как с контроллерами страницы — это практически не отличается от древней методики использования отдельных php-файлов для каждой «страницы» приложения.\r\n\r\nНе заметили ничего необычного? ТТУК выполняет все возможные действия над данными. Почему? Потому что в отсутствие модели вся логика приложения перемещается в контроллер, что делает его своеобразной моделью-мутантом! Я не просто так употребил слово «мутант». ТТУКи очень большие, громоздкие, уродливые и определенно толстые. Есть псевдо-программистский термин, очень точно описывающий происходящее — "раздутые". Они выполняют задачи, для которых никогда не были предназначены. Это полная противоположность всем принципам объектно ориентированного программирования. И они бессмысленны! По каким-то загадочным причинам разработчики предпочитают использовать ТТУКи вместо моделей, несмотря на тот факт, что такие контроллеры на самом деле просто модели-мутанты.\r\n\r\nПомните наше мысленное упражнение? Если вы поместите все в контроллеры, перенос приложения на другой фреймворк станет крайне непростым занятием. Столь жесткое связывание фанаты Кента Бека (Kent Beck) называют «кодом с запашком» (code smell). И это не единственный источник запаха в ТТУКах. ТТУКи большие, с массивными методами, множественными ролям (как правило по одной на каждый метод), множественными повторами кода, не вынесенной во внешние классы функциональностью… ночной кошмар тестировщика. Так как фреймворков много, вы даже не можете правильно применять разработку через тестирование (TDD) без написания собственных дополнений и необходимости обрабатывать объекты запросов, сессии, куки и сбрасывать контроллер входа (Front Controller resets). И даже в этом случае вам придется тестировать созданное контроллером представление, так как у него нет способов вывода, независимых от представлений! \r\n\r\nПродолжим задавать вопросы! Как вы тестируете контроллер? Как вы рефакторите контроллер? Как вы ограничиваете роли контроллера? Какова производительность контроллера? Можно ли создать экземпляр контроллера вне приложения? Могу ли я последовательно объединить несколько контроллеров в один процесс и не сойти с ума? Почему я не использую более простые классы и не называю их моделями? Я вообще задумывался над этими вопросами? \r\n\r\nМодели неизбежны (как смерть и налоги)\r\n\r\nВ ТТУКах совершается классическая ошибка. Считая, что идея модели глупа и простой доступ к данными работает лучше всего, разработчики неосознанно завязывают всю логику приложения на контроллер. Мои поздравления! Вы только что создали модель, дрянную, уродливую модель-мутант, настаивая, что она контроллер. Но этот самозваный контроллер крайне сложно переносить, тестировать, поддерживать и рефакторить (считая рефакторинг понятием из реального мира… такое бывает!) Природа контроллеров такова, что они тесно связаны с лежащим в их основе фреймворком. Вы можете выполнить контроллер только после инициализации всего набора MVC данного фреймворка (что скорее всего означает зависимость от десятков других классов!)\r\n\r\nВы можете пойти другим путем — вынести куда-нибудь логику приложения. Переместив ее из контроллера в модель вы получите много классов, не зависящих от используемого фреймворка. Теперь вы можете сутками тестировать эти рассадники глюков с использованием PHPUnit, ни разу не увидев контроллер или представление и не мучая себя глупыми перезапусками фреймворка после каждого теста. Считая их настоящими классами с четко определенными ролями, вы сможете взглянуть на них с правильной точки зрения, произвести соответствующий рефакторинг и написать по-настоящему поддерживаемый код, не дублируя его по множеству классов. \r\n\r\nМодели неизбежны. Кто-то может называть ТТУК контроллером, но нас самом деле это контроллер+модель, крайне неэффективная замена модели. Некоторые люди просто посмеются над всеми этими дураками, рассуждающими о необходимости хороших и независимых моделей предметной области (good independent domain models), и продолжат писать запутанный код. Пусть смеются. Ведь именно им придется поддерживать и тестировать свой бардак. \r\n\r\nИменно здесь большинство фреймворков для веб-приложений подводят своих пользователей. Они окружены огромным количеством маркетинговой чепухи, неявно предполагающей, что они предлагают полноценную модель. Вы хоть раз видели фреймворк, прямо говорящий нечто иное? В конце концов, это же MVC-фреймворк. Признание того, что разработчик должен писать М самостоятельно, может произвести плохое впечатление. Так что они прячут правду в множестве подробностей, разбросанных по документации доступа к данным или вообще не упоминают о ней. \r\n\r\nНа самом деле они предлагают только классы доступа к данным — настоящая модель отражает особенности конкретного приложения и должна разрабатываться независимо, после общения с клиентами (можете сами подобрать для этого красивое название — лично я предпочитаю «экстремальное программирование»). Ее надо тестировать, проверять, обновлять и вероятность успеха/провала будет неизменной, вне зависимости от используемого фреймворка. Плохое приложение на Rails останется плохим приложением на Code Igniter. \r\n\r\nКонтроллеры не должны охранять данные\r\n\r\nЕще одним следствием всеобщего недоверия к модели является то, что разработчики стараются использовать ее по минимуму и доверяют контроллерам новую роль хранителей данных (одна из главных причин их мутации в ТТУК). Хотите, я еще сильнее разожгу огонь всеобщего несогласия со мной? \r\n\r\nНекоторое время назад я писал проект (Zend_View Enhanced), который рано или поздно будет принят в Zend Framework для внесения объектно-ориентированного подхода в создание сложных представлений, и начал жаловаться на то, что контроллеры являются единственным методом передачи данных из моделей в представления. Я считал, что представления могут обойтись без посредника и использовать вместо него помощников представлений (View Helpers) для чтения данных напрямую из моделей. Это приведет к архитектуре, в которой для многих страниц, доступных только для запросов на чтение, ваше действие контроллера (Controller Action) будет… пустым. В нем не будет никакого кода. Аминь!\r\n\r\nСамый лучший контроллер для меня — это отсутствие контроллера. \r\n\r\nЯ немедленно столкнулся с массовым сопротивлением. Очень немногие поняли, что пустой контроллер, где все взаимодействие с моделью вынесено в простые и повторно используемые помощники представления, сократит повторяющийся код в контроллерах (очень большое количество повторяющегося кода!) и избавит от необходимости выстраивания цепочек действий контроллеров. Вместо этого я услышал немало заковыристых выражений. Многие считали, что MVC работает следующим образом: запросы идут к контроллеру, контроллер получает данные из модели, контроллер передает данные из модели в представление, контроллер отрисовывает представление. Другими словами: контроллер, контроллер, контроллер, контроллер. Однажды я заметил, что сообщество просто одержимо контроллерами. До сих пор очень сложно добиться того, чтобы кто-нибудь дал представлениям объекты с данными и позволил им самостоятельно читать данные из моделей…\r\n\r\nПримечание: не все так плохо — некоторые люди поняли о чем речь \r\n\r\nНикто из возражающих не заметил, что на самом деле это очень старая идея. В Java термин помощник представления ввели много лет назад, как шаблон проектирования в J2EE, показав, что помощники представлений могут помогать представлениям в доступе к моделям (только в чтении, так как все операции записи должны проходить через контроллер!) без посредника-контроллера. Все в MVC говорит о том, что представления должны знать не только о массивах, которые контроллер кладет им в рот, но и о моделях, которые они отображают. \r\n\r\nТак почему бы не пойти дальше! Скольким представлениям хватает одной модели? Многие мои представления используют несколько моделей, обращения к которым очень часто повторяются. Помощник представления — это один класс, но для добавления повторяющихся обращений в контроллеры нам надо повторять эти обращения во множестве методов!\r\n\r\nДля избавления от помощника представлений было придумано одно сумасшедшее решение, при котором действия контроллера переизобрели как многократно используемые команды. Если представлению требуются несколько моделей, вы просто последовательно вызываете несколько контроллеров. Эту идею я нередко называю сцеплением контроллеров (Controller Chaining) — его смысл в создании служебного кода, делающего возможным повторное использование контроллеров. Можете перевести его как: многократное использование любого класса, необходимого для выполнения конкретного действия контроллера. Не забывайте — ни один контроллер невозможно использовать без инициализации всего фреймворка. Хотя есть (всегда есть!) исключения.\r\n\r\nМодели — классы, контроллеры — процессы\r\n\r\nМои нестандартные идеи наверное вас уже утомили, но вышеупомянутое сцепление контроллеров требует более подробного рассмотрения. Сцепление часто используется для доступа к нескольким моделям или объединения результатов нескольких представлений или и для того и для другого одновременно. Последнее случается чаще всего — если вы не используете помощники представлений для упрощения процесса, то контроллеры почти всегда обращаются к моделям и передают данные в представления.\r\n\r\nПредставьте, что вы создали три контроллера, каждый из которых создает представление. Чтобы создать некую новую веб-страницу вам необходимо объединить три представления в единую страницу по шаблону (или макету). Это делается последовательным вызовом всех трех контроллеров через Zend_Layout (или какое-нибудь другое решение для сборки представлений в один макет/секцию). А теперь посмотрим, что получилось — три контроллера означают, что мы три раза выполняем стек MVC. В зависимости от приложения это может привести к значительным затратам ресурсов. Просто для примера величины этих затрат, Symfony использует «компоненты» (“Components”) как специализированные типы контроллеров, предназначенные исключительно для смягчения удара по производительности, но в Zend Framework нет ничего подобного. Схожая идея в Rails вызывала массу жалоб на падения производительности. Расхожая мудрость гласит, что использование нескольких полных контроллеров в фреймворках чудовищно неэффективно и является последней надеждой в тех случаях, когда нет иных стратегий повторного использования. \r\n\r\nПовторюсь, сцепление контроллеров — это код с запашком. Оно неэффективно, неуклюже и как правило не нужно.\r\n\r\nАльтернативой, само собой, является использование частичных представлений (кусочков шаблона, способных объединиться в одно родительское представление), способных напрямую взаимодействовать с моделью через помощник представления. Избавьтесь от контроллеров в целом — в конце концов в них нет никакой логики приложения, кроме передачи пользовательского ввода соответствующему вызову модели (за исключением ТТУКов).\r\n\r\nОсновная идея в том, что модель — это просто набор слабо связанных классов. Вы можете создавать и использовать их экземпляры где угодно — в других моделях, контроллерах и даже представлениях! С другой стороны, контроллер является неотъемлемой частью общего процесса. Вы не можете повторно использовать контроллер не запуская весь процесс создания объектов запроса, диспетчеризации, применения помощников действий, инициализации представления и обработки возвращаемых объектов ответа. Это затратно и неуклюже. \r\n\r\nВ завершение разговора\r\n\r\nКак вы могли заметить, эта статья была жизненно необходима. Я твердо уверен в необходимости внедрения изящных принципов объектно ориентированного программирования в MVC фреймворки. Именно поэтому я всеми силами продвигал Zend_View Enhanced в Zend Framework и видел, как его одобряли, обсуждали и крайне успешно использовали. Во многом это произошло благодаря Мэтью Вейнеру О''Финли (Matthew Weier O’Phinney) и Ральфу Шиндлеру (Ralph Schindler), присоединившимся к продвижению этой идеи. Забыв о простых методиках и принципах ООП мы завязнем в борьбе с MVC, забыв о его смысле. MVC — это великий архитектурный шаблон, но в конце концов любые наши толкования MVC и привычные убеждения производны от принципов ООП. Забыв об этом, мы начнем делать Плохие Вещи (ТМ). \r\n\r\nНадеюсь этот поток мыслей о модели в модели-контроллере-представлении окажется чем-то просветляющим и заставит вас задуматься. Вашей целью должно быть самостоятельно мышление — сомневайтесь во всем и восставайте, когда что-то покажется вам неправильным. Полагаясь на слепую веру мы заслуживаем всего, что с нами происходит. ');

-- --------------------------------------------------------

--
-- Структура таблицы `portfolio`
--

CREATE TABLE IF NOT EXISTS `portfolio` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `year` varchar(100) NOT NULL,
  `url` varchar(255) NOT NULL,
  `description` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

--
-- Дамп данных таблицы `portfolio`
--

INSERT INTO `portfolio` (`id`, `year`, `url`, `description`) VALUES
(1, '2010', 'http://DunkelBeer.ru', 'Промо-сайт темного пива Dunkel от немецкого производителя Löwenbraü выпускаемого в России пивоваренной компанией "CАН ИнБев".'),
(2, '2012', 'http://ZopoMobile.ru', 'Русскоязычный каталог китайских телефонов компании Zopo на базе Android OS и аксессуаров к ним.');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
